<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSCI-1250: Arrays, Looping, and Memory Concepts - Lecture Slides</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="https://csci-1250.github.io/class_resources_public/templates/css/slides_primary_theme.css">

    <!-- Prism CSS for syntax highlighting -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/themes/prism.css" rel="stylesheet" />

    <!-- jsPDF and html2canvas for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- Prism JS for syntax highlighting -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-csharp.min.js"></script>

    <style>
        .code-block {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 15px;
            padding: 4px 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            font-weight: 500;
            margin: 15px 0;
            overflow-x: auto;
        }
        
        .memory-diagram {
            background: #f8f9fa;
            border: 2px solid #1D4ED8;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .stack-heap-visual {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .stack-box, .heap-box {
            border: 2px solid #DC2626;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .heap-box {
            border-color: #1D4ED8;
        }
        
        .type-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .type-table th {
            background: #DC2626;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.1em;
        }
        
        .type-table td {
            padding: 15px;
            text-align: center;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .type-table tbody tr:hover {
            background: #f9fafb;
        }
    </style>
</head>
<body>
    <!-- Loading overlay for PDF generation -->
    <div class="pdf-loading" id="pdfLoading">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="progress-text" id="progressText">üéØ Generating PDF...</div>
            <div style="font-size: 0.9em; margin-bottom: 15px;">
                <span id="slideCounter">Slide 0 of 12</span>
            </div>
            <div class="slide-progress">
                <div class="slide-progress-fill" id="slideProgressFill" style="width: 0%"></div>
            </div>
            <div style="font-size: 0.8em; margin-top: 15px; opacity: 0.8;">
                This may take a few moments...
            </div>
        </div>
    </div>

    <div class="presentation-container">
        <div class="header">
            <h1>CSCI-1250: Arrays, Looping, and Memory Concepts</h1>
            <div class="header-right">
                <button class="download-btn" id="downloadPDF" onclick="generatePDF()">
                    <span class="download-icon">üìÑ</span>
                    <span>Download PDF</span>
                </button>
                <div class="slide-counter">
                    <span id="current-slide">1</span> / <span id="total-slides">12</span>
                </div>
            </div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>

        <div class="slide-content">
            <!-- Slide 1: Title Slide -->
            <div class="slide active">
                <div class="slide-title">Arrays, Looping, and Memory Concepts</div>
                <div style="text-align: center; margin-top: 50px;">
                    <div style="font-size: 1.5em; color: #1F2937; margin-bottom: 30px;">
                        Understanding Data Storage and Memory Management
                    </div>
                    <div style="background: linear-gradient(135deg, #DC2626, #B91C1C); color: white; padding: 30px; border-radius: 15px; max-width: 800px; margin: 0 auto;">
                        <p style="font-size: 1.2em; margin-bottom: 15px;"><strong>Today's Topics:</strong></p>
                        <ul style="list-style: none; font-size: 1.1em;">
                            <li style="padding: 8px 0;">üìä Arrays in C# (static context)</li>
                            <li style="padding: 8px 0;">üîÑ Looping through arrays</li>
                            <li style="padding: 8px 0;">üß† Stack vs Heap memory</li>
                            <li style="padding: 8px 0;">‚öôÔ∏è Hardware and compilation</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Slide 2: What is an Array? -->
            <div class="slide">
                <div class="slide-title">What is an Array?</div>
                <div class="highlight-box">
                    <h3>üìä Definition</h3>
                    <p style="font-size: 1.2em; line-height: 1.6;">
                        An <strong>array</strong> is a collection of elements of the same type, stored in contiguous memory locations. Think of it as a row of boxes, each containing a value.
                    </p>
                </div>
                <div class="info-grid">
                    <div class="info-card">
                        <h3>üéØ Key Properties</h3>
                        <ul class="bullet-points">
                            <li>Fixed size once created</li>
                            <li>All elements same data type</li>
                            <li>Elements accessed by index</li>
                            <li>Zero-based indexing (starts at 0)</li>
                        </ul>
                    </div>
                    <div class="info-card blue">
                        <h3>üí° Why Use Arrays?</h3>
                        <ul class="bullet-points">
                            <li>Store multiple related values</li>
                            <li>Efficient memory usage</li>
                            <li>Easy to loop through data</li>
                            <li>Foundation for data structures</li>
                        </ul>
                    </div>
                </div>
                <div class="memory-diagram">
                    <strong>Visual: Array in Memory</strong><br>
                    [Value1] [Value2] [Value3] [Value4] [Value5]<br>
                    &nbsp;&nbsp;Index 0&nbsp;&nbsp;&nbsp;&nbsp;Index 1&nbsp;&nbsp;&nbsp;&nbsp;Index 2&nbsp;&nbsp;&nbsp;&nbsp;Index 3&nbsp;&nbsp;&nbsp;&nbsp;Index 4
                </div>
            </div>

            <!-- Slide 3: Creating Arrays in C# -->
            <div class="slide">
                <div class="slide-title">Creating Arrays in C# (Static Context)</div>
                <div class="highlight-box">
                    <h3>üîß Array Declaration and Initialization</h3>
                    <p>Since we're working in static methods, all our array examples will be within static contexts.</p>
                </div>
                
                <div class="code-block"><pre><code class="language-csharp">
<strong>// Method 1: Declare size, then assign values</strong>
static void Main(string[] args)
{
    int[] numbers = new int[5];  // Creates array of 5 integers
    numbers[0] = 10;
    numbers[1] = 20;
    numbers[2] = 30;
    numbers[3] = 40;
    numbers[4] = 50;
}

<strong>// Method 2: Initialize with values directly</strong>
static void ProcessGrades()
{
    int[] grades = {85, 92, 78, 96, 88};  // Size automatically determined
    // OR equivalently:
    int[] grades2 = new int[] {85, 92, 78, 96, 88};
}

<strong>// Method 3: Different data types</strong>
static void ExampleArrays()
{
    string[] names = {"Alice", "Bob", "Charlie"};
    double[] prices = {19.99, 25.50, 12.75};
    bool[] flags = {true, false, true, true};
}
                </pre></code></div>
            </div>

            <!-- Slide 4: Accessing Array Elements -->
            <div class="slide">
                <div class="slide-title">Accessing and Modifying Array Elements</div>
                
                <div class="info-grid">
                    <div class="info-card">
                        <h3>üìñ Reading Values</h3>
                        <ul class="bullet-points">
                            <li>Use square brackets with index</li>
                            <li>Remember: first element is index 0</li>
                            <li>Last element is at index (length - 1)</li>
                        </ul>
                    </div>
                    <div class="info-card blue">
                        <h3>‚úèÔ∏è Writing Values</h3>
                        <ul class="bullet-points">
                            <li>Same syntax for assignment</li>
                            <li>Can modify existing elements</li>
                            <li>Cannot change array size</li>
                        </ul>
                    </div>
                </div>

                <div class="code-block"><pre><code class="language-csharp">
<strong>// Example: Student test scores</strong>
static void AnalyzeScores()
{
    int[] testScores = {85, 92, 78, 96, 88};
    
    <strong>// Accessing elements</strong>
    Console.WriteLine("First score: " + testScores[0]);     // Outputs: 85
    Console.WriteLine("Last score: " + testScores[4]);      // Outputs: 88
    Console.WriteLine("Array length: " + testScores.Length); // Outputs: 5
    
    <strong>// Modifying elements</strong>
    testScores[2] = 82;  // Changed 78 to 82
    Console.WriteLine("Updated third score: " + testScores[2]); // Outputs: 82
    
    <strong>// Common mistake - index out of bounds!</strong>
    // testScores[5] = 100;  // ERROR! Index 5 doesn't exist
}
                </pre></code></div>
            </div>

            <!-- Slide 5: Looping Through Arrays -->
            <div class="slide">
                <div class="slide-title">Looping Through Arrays</div>
                
                <div class="highlight-box blue">
                    <h3>üîÑ Why Loop Through Arrays?</h3>
                    <p>Arrays and loops are perfect partners! Instead of accessing each element individually, we can process all elements efficiently.</p>
                </div>

                <div class="code-block"><pre><code class="language-csharp">
<strong>// Method 1: Traditional for loop</strong>
static void PrintScoresForLoop()
{
    int[] scores = {85, 92, 78, 96, 88};
    
    for (int i = 0; i < scores.Length; i++)
    {
        Console.WriteLine("Score " + (i + 1) + ": " + scores[i]);
    }
}

<strong>// Method 2: Foreach loop (cleaner for reading)</strong>
static void PrintScoresForEach()
{
    int[] scores = {85, 92, 78, 96, 88};
    
    foreach (int score in scores)
    {
        Console.WriteLine("Score: " + score);
    }
}

<strong>// Method 3: While loop (less common for arrays)</strong>
static void PrintScoresWhile()
{
    int[] scores = {85, 92, 78, 96, 88};
    int index = 0;
    
    while (index < scores.Length)
    {
        Console.WriteLine("Score: " + scores[index]);
        index++;
    }
}
                </pre></code></div>
            </div>

            <!-- Slide 6: Array Copying Problem -->
            <div class="slide">
                <div class="slide-title">The Array Copying Problem</div>
                
                <div class="highlight-box yellow">
                    <h3>‚ö†Ô∏è What Happens When We "Copy" an Array?</h3>
                    <p>Let's see what happens when we try to copy an array using simple assignment...</p>
                </div>

                <div class="code-block"><pre><code class="language-csharp">
<strong>// What do you think this code does?</strong>
static void ArrayCopyingProblem()
{
    int[] originalScores = {85, 92, 78};
    int[] copiedScores = originalScores;  // Is this a copy?
    
    Console.WriteLine("Original before change:");
    foreach (int score in originalScores)
        Console.Write(score + " ");  // Outputs: 85 92 78
    
    <strong>// Let's modify the "copy"</strong>
    copiedScores[0] = 100;
    
    Console.WriteLine("\nOriginal after changing 'copy':");
    foreach (int score in originalScores)
        Console.Write(score + " ");  // Outputs: 100 92 78  ‚Üê SURPRISE!
    
    Console.WriteLine("\n'Copied' array:");
    foreach (int score in copiedScores)
        Console.Write(score + " ");  // Outputs: 100 92 78
}
                </pre></code></div>
                
                <div class="info-card">
                    <h3>ü§î What Just Happened?</h3>
                    <p>Both variables point to the <strong>same array in memory</strong>! This is called a <strong>shallow copy</strong>. To understand why, we need to learn about how memory works...</p>
                </div>
            </div>

            <!-- Slide 7: Primitives vs Reference Types -->
            <div class="slide">
                <div class="slide-title">Primitives vs Reference Types</div>
                
                <div class="info-grid">
                    <div class="info-card">
                        <h3>üî¢ Primitive Types</h3>
                        <ul class="bullet-points">
                            <li>Store the actual value</li>
                            <li>Stored on the Stack</li>
                            <li>Copying creates new value</li>
                            <li>Examples: int, double, bool, char</li>
                        </ul>
                    </div>
                    <div class="info-card blue">
                        <h3>üìä Reference Types</h3>
                        <ul class="bullet-points">
                            <li>Store a reference (address)</li>
                            <li>Actual data stored on Heap</li>
                            <li>Copying copies the reference</li>
                            <li>Examples: arrays, strings, objects</li>
                        </ul>
                    </div>
                </div>

                <div class="code-block"><pre><code class="language-csharp">
<strong>// Primitive behavior (normal copying)</strong>
int a = 10;
int b = a;    // b gets its own copy of the value 10
a = 20;       // Only a changes, b is still 10

<strong>// Reference type behavior (reference copying)</strong>
int[] array1 = {1, 2, 3};
int[] array2 = array1;  // array2 gets copy of the reference, not the data!
array1[0] = 999;        // Changes the data that both references point to
// Now both array1[0] and array2[0] are 999!
                </pre></code></div>
                
                <div class="highlight-box">
                    <h3>üí° Key Insight</h3>
                    <p>Understanding the difference between <strong>value types</strong> (primitives) and <strong>reference types</strong> (arrays, objects) is crucial for avoiding bugs and understanding memory usage!</p>
                </div>
            </div>

            <!-- Slide 8: Stack vs Heap Memory -->
            <div class="slide">
                <div class="slide-title">Stack vs Heap Memory</div>
                
                <div class="stack-heap-visual">
                    <div class="stack-box">
                        <h3>üìö The Stack</h3>
                        <ul class="bullet-points" style="text-align: left;">
                            <li>Fast access</li>
                            <li>Stores local variables</li>
                            <li>Stores method parameters</li>
                            <li>Stores references to heap objects</li>
                            <li>LIFO (Last In, First Out)</li>
                            <li>Limited size</li>
                        </ul>
                    </div>
                    <div class="heap-box">
                        <h3>üèóÔ∏è The Heap</h3>
                        <ul class="bullet-points" style="text-align: left;">
                            <li>Slower access than stack</li>
                            <li>Stores objects and arrays</li>
                            <li>Dynamic allocation</li>
                            <li>Managed by Garbage Collector</li>
                            <li>Much larger than stack</li>
                            <li>Shared across threads</li>
                        </ul>
                    </div>
                </div>

                <div class="code-block"><pre><code class="language-csharp">
<strong>// Example: What goes where?</strong>
static void MemoryExample()
{
    int number = 42;              // Stack: stores the value 42
    int[] numbers = {1, 2, 3};    // Stack: stores reference to heap
                                  // Heap: stores the actual array data
    
    string text = "Hello";        // Stack: stores reference to heap
                                  // Heap: stores the actual string data
}
                </pre></code></div>
            </div>

            <!-- Slide 9: Hardware Components and Program Execution -->
            <div class="slide">
                <div class="slide-title">Hardware Components in Program Execution</div>
                
                <div class="info-grid">
                    <div class="info-card">
                        <h3>üß† CPU (Central Processing Unit)</h3>
                        <ul class="bullet-points">
                            <li>Executes program instructions</li>
                            <li>Performs calculations</li>
                            <li>Controls program flow</li>
                            <li>Has built-in cache memory</li>
                        </ul>
                    </div>
                    <div class="info-card blue">
                        <h3>üßÆ Memory (RAM)</h3>
                        <ul class="bullet-points">
                            <li>Stores program code while running</li>
                            <li>Contains the Stack and Heap</li>
                            <li>Fast access for CPU</li>
                            <li>Volatile (lost when power off)</li>
                        </ul>
                    </div>
                    <div class="info-card yellow">
                        <h3>üíæ Storage (Hard Drive/SSD)</h3>
                        <ul class="bullet-points">
                            <li>Stores compiled programs (.exe)</li>
                            <li>Stores source code files (.cs)</li>
                            <li>Persistent (survives power off)</li>
                            <li>Slower than memory</li>
                        </ul>
                    </div>
                    <div class="info-card">
                        <h3>üéÆ GPU (Graphics Processing Unit)</h3>
                        <ul class="bullet-points">
                            <li>Specialized for parallel processing</li>
                            <li>Handles graphics and visual output</li>
                            <li>Can accelerate certain computations</li>
                            <li>Important for game development</li>
                        </ul>
                    </div>
                </div>
                
                <div class="highlight-box blue">
                    <h3>üîÑ The Execution Flow</h3>
                    <p>Storage ‚Üí Memory ‚Üí CPU ‚Üí (Results back to Memory) ‚Üí Storage (if saved)</p>
                </div>
            </div>

            <!-- Slide 10: Primitive Types and Memory -->
            <div class="slide">
                <div class="slide-title">C# Primitive Types and Memory Usage</div>
                
                <table class="type-table">
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Size (bytes)</th>
                            <th>Range/Values</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>bool</strong></td>
                            <td>1</td>
                            <td>true or false</td>
                            <td>bool isReady = true;</td>
                        </tr>
                        <tr>
                            <td><strong>byte</strong></td>
                            <td>1</td>
                            <td>0 to 255</td>
                            <td>byte age = 25;</td>
                        </tr>
                        <tr>
                            <td><strong>char</strong></td>
                            <td>2</td>
                            <td>Any Unicode character</td>
                            <td>char grade = 'A';</td>
                        </tr>
                        <tr>
                            <td><strong>int</strong></td>
                            <td>4</td>
                            <td>-2.1 billion to 2.1 billion</td>
                            <td>int score = 95;</td>
                        </tr>
                        <tr>
                            <td><strong>long</strong></td>
                            <td>8</td>
                            <td>Very large integers</td>
                            <td>long population = 7800000000L;</td>
                        </tr>
                        <tr>
                            <td><strong>float</strong></td>
                            <td>4</td>
                            <td>~6-7 decimal digits</td>
                            <td>float price = 19.99f;</td>
                        </tr>
                        <tr>
                            <td><strong>double</strong></td>
                            <td>8</td>
                            <td>~15-16 decimal digits</td>
                            <td>double precise = 3.14159265;</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="highlight-box">
                    <h3>üî¢ Binary Representation</h3>
                    <p><strong>Example:</strong> The int value 42 is stored as 32 bits: 00000000 00000000 00000000 00101010</p>
                </div>
            </div>

            <!-- Slide 11: Compilation and Runtime -->
            <div class="slide">
                <div class="slide-title">Compilation and Runtime Process</div>
                
                <div class="info-grid">
                    <div class="info-card">
                        <h3>üî® Compilation (dotnet build)</h3>
                        <ul class="bullet-points">
                            <li>Translates C# source code (.cs)</li>
                            <li>Creates intermediate language (IL)</li>
                            <li>Performs syntax checking</li>
                            <li>Produces executable files (.exe, .dll)</li>
                            <li>Happens before program runs</li>
                        </ul>
                    </div>
                    <div class="info-card blue">
                        <h3>üèÉ Runtime (dotnet run)</h3>
                        <ul class="bullet-points">
                            <li>Loads compiled program into memory</li>
                            <li>Just-In-Time (JIT) compilation to machine code</li>
                            <li>Allocates stack and heap memory</li>
                            <li>Executes instructions on CPU</li>
                            <li>Manages memory (Garbage Collection)</li>
                        </ul>
                    </div>
                </div>
                
                <div class="memory-diagram">
                    <strong>The Process:</strong><br>
                    Source Code (.cs) ‚Üí <strong>[dotnet build]</strong> ‚Üí IL Code (.exe/.dll) ‚Üí <strong>[dotnet run]</strong> ‚Üí Machine Code ‚Üí CPU Execution
                </div>
                
                <div class="highlight-box yellow">
                    <h3>üí° Why This Two-Step Process?</h3>
                    <p>The .NET runtime can optimize your code for the specific machine it's running on, making it faster and more efficient than purely interpreted languages!</p>
                </div>
            </div>

            <!-- Slide 12: Practical Array Examples and Challenges -->
            <div class="slide">
                <div class="slide-title">Practical Array Examples & Challenges</div>
                
                <div class="code-block"><pre><code class="language-csharp">
<strong>// Example 1: Calculate average of test scores</strong>
static double CalculateAverage(int[] scores)
{
    int sum = 0;
    foreach (int score in scores)
    {
        sum += score;
    }
    return (double)sum / scores.Length;
}

<strong>// Example 2: Find the highest score</strong>
static int FindMaxScore(int[] scores)
{
    int max = scores[0];  // Assume first element is largest
    for (int i = 1; i < scores.Length; i++)
    {
        if (scores[i] > max)
        {
            max = scores[i];
        }
    }
    return max;
}

<strong>// Example 3: Count how many scores are above average</strong>
static int CountAboveAverage(int[] scores)
{
    double average = CalculateAverage(scores);
    int count = 0;
    foreach (int score in scores)
    {
        if (score > average)
        {
            count++;
        }
    }
    return count;
}
                </pre></code></div>
                
                <div class="highlight-box blue">
                    <h3>üéØ Challenge Time!</h3>
                    <p><strong>Try These:</strong> Create a method to reverse an array, find the second-largest value, or determine if an array contains a specific value. Remember to work within static methods!</p>
                </div>
            </div>
        </div>

        <div class="navigation">
            <button class="nav-button" id="prev-btn" onclick="previousSlide()">
                ‚Üê Previous
            </button>
            <div class="timer-display" id="timer">
                00:00
            </div>
            <button class="nav-button" id="next-btn" onclick="nextSlide()">
                Next ‚Üí
            </button>
        </div>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        let startTime = Date.now();
        let timerInterval;

        // Initialize
        document.getElementById('total-slides').textContent = totalSlides;
        updateSlideDisplay();
        startTimer();

        function updateSlideDisplay() {
            // Hide all slides
            slides.forEach(slide => slide.classList.remove('active'));
            
            // Show current slide
            slides[currentSlide].classList.add('active');
            
            // Update counter
            document.getElementById('current-slide').textContent = currentSlide + 1;
            
            // Update progress bar
            const progress = ((currentSlide + 1) / totalSlides) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            
            // Update navigation buttons
            document.getElementById('prev-btn').disabled = currentSlide === 0;
            document.getElementById('next-btn').disabled = currentSlide === totalSlides - 1;
        }

        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                currentSlide++;
                updateSlideDisplay();
            }
        }

        function previousSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                updateSlideDisplay();
            }
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // PDF Generation Function (same as original)
        async function generatePDF() {
            console.log('üéØ INITIATING PDF GENERATION...');

            await document.fonts.ready;
            
            // Show loading overlay
            const loadingOverlay = document.getElementById('pdfLoading');
            const progressText = document.getElementById('progressText');
            const slideCounter = document.getElementById('slideCounter');
            const slideProgressFill = document.getElementById('slideProgressFill');
            const downloadBtn = document.getElementById('downloadPDF');
            
            loadingOverlay.classList.add('active');
            downloadBtn.disabled = true;
            
            try {
                // Initialize jsPDF with Letter size
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'in',
                    format: 'letter'
                });
                
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 0.5;
                const contentWidth = pageWidth - (2 * margin);
                const contentHeight = pageHeight - (2 * margin);
                
                console.log(`üìè PDF dimensions: ${pageWidth}" x ${pageHeight}"`);
                
                // Get all slides and prepare for generation
                const slideElements = document.querySelectorAll('.slide');
                const originalSlideContent = document.querySelector('.slide-content');
                
                // Store original styles
                const originalStyles = {
                    slideContent: originalSlideContent.style.cssText,
                    slides: Array.from(slideElements).map(slide => slide.style.cssText)
                };
                
                // Apply PDF-friendly styles
                originalSlideContent.style.cssText += `
                    overflow: visible !important;
                    height: auto !important;
                    padding: 0 !important;
                `;

                document.body.classList.add('pdf-mode');
                
                slideElements.forEach((slide, index) => {
                    slide.style.cssText += `
                        display: block !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        position: static !important;
                        height: auto !important;
                        min-height: 800px !important;
                        background: white !important;
                        margin-bottom: 20px !important;
                        padding: 40px !important;
                        page-break-after: always;
                        border: none !important;
                    `;
                });
                
                // Process each slide individually
                for (let i = 0; i < slideElements.length; i++) {
                    const slide = slideElements[i];
                    
                    progressText.textContent = `üñºÔ∏è Capturing slide ${i + 1}...`;
                    slideCounter.textContent = `Slide ${i + 1} of ${slideElements.length}`;
                    slideProgressFill.style.width = `${((i + 1) / slideElements.length) * 100}%`;
                    
                    // Hide all slides except current one
                    slideElements.forEach((s, idx) => {
                        if (idx !== i) {
                            s.style.display = 'none';
                        }
                    });
                    
                    // Force reflow and wait for rendering
                    slide.offsetHeight;
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    try {
                        // Capture the individual slide
                        const canvas = await html2canvas(slide, {
                            allowTaint: true,
                            removeContainer: false,
                            useCORS: true,
                            scale: 2,
                            width: slide.scrollWidth,
                            height: slide.scrollHeight,
                            backgroundColor: '#ffffff',
                            logging: false,
                            onclone: (clonedDoc) => {
                                const clonedSlides = clonedDoc.querySelectorAll('.slide');
                                clonedSlides.forEach(s => {
                                    s.style.display = 'block';
                                    s.style.opacity = '1';
                                    s.style.visibility = 'visible';
                                });
                            }
                        });
                        
                        console.log(`üìä Slide ${i + 1} canvas: ${canvas.width}x${canvas.height}`);
                        
                        // Calculate scaling to fit page
                        const canvasAspectRatio = canvas.width / canvas.height;
                        const pageAspectRatio = contentWidth / contentHeight;
                        
                        let finalWidth, finalHeight;
                        if (canvasAspectRatio > pageAspectRatio) {
                            finalWidth = contentWidth;
                            finalHeight = contentWidth / canvasAspectRatio;
                        } else {
                            finalHeight = contentHeight;
                            finalWidth = contentHeight * canvasAspectRatio;
                        }
                        
                        // Center the image on page
                        const x = (pageWidth - finalWidth) / 2;
                        const y = (pageHeight - finalHeight) / 2;
                        
                        // Add to PDF
                        if (i > 0) {
                            pdf.addPage();
                        }
                        
                        progressText.textContent = `üìù Adding slide ${i + 1} to PDF...`;
                        
                        pdf.addImage(
                            canvas.toDataURL('image/jpeg', 0.85),
                            'JPEG',
                            x, y,
                            finalWidth, finalHeight
                        );
                        
                        console.log(`‚úÖ Added slide ${i + 1} to PDF`);
                        
                    } catch (slideError) {
                        console.error(`‚ùå Error capturing slide ${i + 1}:`, slideError);
                        
                        // Add error page instead of failing completely
                        if (i > 0) {
                            pdf.addPage();
                        }
                        
                        pdf.setFontSize(20);
                        pdf.setTextColor(220, 53, 69);
                        pdf.text(`Error capturing slide ${i + 1}`, pageWidth / 2, pageHeight / 2, { align: 'center' });
                        pdf.setFontSize(12);
                        pdf.setTextColor(108, 117, 125);
                        pdf.text('This slide could not be rendered properly', pageWidth / 2, (pageHeight / 2) + 0.5, { align: 'center' });
                    }
                }

                document.body.classList.remove('pdf-mode');
                
                // Restore all slides visibility
                slideElements.forEach(slide => {
                    slide.style.display = 'block';
                });
                
                // Restore original styles
                progressText.textContent = 'üßπ Cleaning up...';
                originalSlideContent.style.cssText = originalStyles.slideContent;
                slideElements.forEach((slide, index) => {
                    slide.style.cssText = originalStyles.slides[index];
                });
                
                // Save the PDF
                progressText.textContent = 'üíæ Saving PDF...';
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const fileName = `CSCI-1250_Arrays-Memory-Concepts_${new Date().toISOString().split('T')[0]}.pdf`;
                pdf.save(fileName);
                
                // Success!
                progressText.textContent = 'üéâ PDF Generated Successfully!';
                slideCounter.textContent = `‚úÖ All ${slideElements.length} slides exported`;
                slideProgressFill.style.width = '100%';
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                
            } catch (error) {
                console.error('üíÄ PDF GENERATION FAILED:', error);
                
                progressText.textContent = '‚ùå PDF Generation Failed';
                slideCounter.textContent = 'Error occurred - check console';
                
                await new Promise(resolve => setTimeout(resolve, 3000));
            } finally {
                // Always hide loading and re-enable button
                loadingOverlay.classList.remove('active');
                downloadBtn.disabled = false;
                updateSlideDisplay(); // Restore normal navigation
            }
        }
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ' || e.key === 'PageDown') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
                e.preventDefault();
                previousSlide();
            } else if (e.key === 'Home') {
                e.preventDefault();
                currentSlide = 0;
                updateSlideDisplay();
            } else if (e.key === 'End') {
                e.preventDefault();
                currentSlide = totalSlides - 1;
                updateSlideDisplay();
            }
        });

        // Touch/swipe support for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            if (touchStartX - touchEndX > 50) {
                nextSlide(); // Swipe left
            } else if (touchEndX - touchStartX > 50) {
                previousSlide(); // Swipe right
            }
        });
    </script>
</body>
</html>
                    